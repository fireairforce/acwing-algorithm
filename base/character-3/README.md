## DFS 和 BFS 
DFS 不具备最短路的性质，BFS 能搜到最短的路径，DFS 的空间消耗是要比 BFS 少很多的。DFS 使用 stask，而 BFS 使用 queue.

DFS 里面重要的两个概念为回溯和剪枝。

每个 DFS 都对应这一条搜索树。常见的例题可以看相关文件。
DFS 要思考一下顺序，使用一个怎么样的顺序去做一个遍历的方案。DFS 在回溯的时候**系统会为我们维护一个栈结构的**，因此我们不需要再去开空间去记录路径。

## 拓扑排序
拓扑序列只存在于有向图中，无向图是不存在拓扑序列的。(拓扑这个词是英文释意)。

拓扑序列要求每条边，起点都在终点的前面，这样才能构成一个拓扑序列。

只要图中存在环，那是一定不会存在拓扑序列的，有向无环图(DAG，也被称为拓扑图)是一定存在拓扑序列的。

拓扑序列是非常容易求的，根据入度和出度去做一个计算就可以了。

拓扑排序中，所有入度为0的点，都是可以作为起点的(因为不会有任意一条边指向该点)。

```bash
// 如果图上存在环的话，那么就存在突破不掉的点放不进去队列里面(环无论怎么删，都存在入度不为0的点)
queue <-  入度为 0 的点(放入队列中)
while queue 不空 {
  t <- 队头
  枚举 t 的所有出边(例如 t -> j)
    删掉 t -> j (使j的入度(如果用 d[j] 表示，那就 d[j]--))
    if (d[j] === 0) {
      queue <- j // 删了之后把 j 这个点放在队列里面去
    }
}
```

## DFS 和 BFS 
DFS 不具备最短路的性质，BFS 能搜到最短的路径，DFS 的空间消耗是要比 BFS 少很多的。DFS 使用 stask，而 BFS 使用 queue.

DFS 里面重要的两个概念为回溯和剪枝。

每个 DFS 都对应这一条搜索树。常见的例题可以看相关文件。
DFS 要思考一下顺序，使用一个怎么样的顺序去做一个遍历的方案。DFS 在回溯的时候**系统会为我们维护一个栈结构的**，因此我们不需要再去开空间去记录路径。

BFS 能够搜到最短的路径。

宽搜的基本框架
```bash
queue <- 初始
while queue 不空 {
  队头 <- t
  拓展 t
}

```

## 树与图的遍历
在研究遍历之前，是需要先研究一下树与图是如何进行存储的。

树其实就是一种特殊的图 **(无环联通图)**。因此我们其实只用学习图相关即可。

图可以分为无向图和有向图。(边是否存在方向)，无向图在算法里面需要建立两条边(从a->b即b->a)。无向图其实是一种特殊的有向图。

有向图则分为两种，一种是领接矩阵 `g[a,b]` 表示从 a -> b，空间复杂度是 O(N^2)，一般用的比较少。
另外一种是 领接表 (则是单链表)，领接表存储有向图相当于在每个点上存一个链表(每个点上都存一个单链表，存储这个点可以达到哪些点)。

代码参考树的重心。

注意树和图的遍历每个点都只会走一遍，因此算法的时间复杂度其实就是 O(N+M),N为点的数目，M 为点的数目，成一个线性的关系。


## 拓扑排序
拓扑序列是图的宽搜的一种很基本的方法。

拓扑序列只存在于有向图中，无向图是不存在拓扑序列的。(拓扑这个词是英文释意)。

拓扑序列要求每条边，起点都在终点的前面，这样才能构成一个拓扑序列。

只要图中存在环，那是一定不会存在拓扑序列的，有向无环图(DAG，也被称为拓扑图)是一定存在拓扑序列的。

拓扑序列是非常容易求的，根据入度和出度去做一个计算就可以了。

拓扑排序中，所有入度为0的点，都是可以作为起点的(因为不会有任意一条边指向该点)。

```bash
// 如果图上存在环的话，那么就存在突破不掉的点放不进去队列里面(环无论怎么删，都存在入度不为0的点)
queue <-  入度为 0 的点(放入队列中)
while queue 不空 {
  t <- 队头
  枚举 t 的所有出边(例如 t -> j)
    删掉 t -> j (使j的入度(如果用 d[j] 表示，那就 d[j]--))
    if (d[j] === 0) {
      queue <- j // 删了之后把 j 这个点放在队列里面去
    }
}
```

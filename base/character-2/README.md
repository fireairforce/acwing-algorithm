# Data-Structure

前面几种数据结构都是以数组模拟的。
原因如下:
- 效率问题
例如链表:
```cpp
struct Node 
{
  int val;
  Node *next;
}
```
每次 new 一个新的节点都会去调用结构体，消耗很大，平时做笔试的时候不会采用这种动态的方式。(可以改进之后使用，例如初始化的时候做一些处理)。一般都采用数组来去做模拟，即静态链表的。

## 链表 && 邻接表
链表可以用指针 + 结构体。但如上效率是很低的，因此这里都是采用数组来进行模拟。

### 单链表
单链表里面用比较多的是领接表(用来存储图和树)

单链表是可以在任意位置插入值的，但是想实现在 O(1) 的时间之内插入某个值，需要确定插入的位置，因为单链表能在O(1)的时间里面找到某个节点的下一个节点的值，但是不能找到其上一个节点的值。

### 双链表
一般用来优化某些问题.
相比较于单链表存在两个指针。一个指向前面，一个指向后面。
```bash
一般我们定义 int l[N], r[N]; 来存节点
让下标为 0 的点为 head, 下标为 1 的点为 tail
```

## 栈与队列

栈:
```cpp
const int N = 100010;

int stk[N], tt;

// insert
stk[++tt] = x;

// 弹出
tt --;

// 判断栈位空
if (tt > 0) // 不空
// 否则空

// 栈顶 
stk[tt]
```

队列:
```cpp
// 在队尾插入元素，队头弹出元素
int q[N], hh, tt = -1;

// 插入
q[++tt] = x;

// 弹出 
hh ++;

if (hh <= tt) {
  // not empty
} else {
  // empty
}

// 取出队头元素
q[hh]
// 队尾元素
q[tt]
```

## 单调栈
最常见的一个应用情景是给定一个序列，要求求出每个数`左边/右边`离它最近的比它`大/小`的数。

可以见例题。单调栈考虑的方式考虑方式其实和双指针差不多。用于降低问题的时间复杂度。

暴力解法走个两层循环就可以出来结果。因此考虑在外层循环的时候使用一个栈来作为优化。

## 单调队列
单调队列最常见的应用就是求出滑动窗口里面的最大值和最小值。(时间复杂度为 O(N))。

## kmp
kmp 算法是在模版串 `S` 中匹配另外一个比较短的字符串 `P` 的算法。
kmp 算法的思考本质其实和单调队列、单调栈、双指针算法这些算法思想是差不多的。
我们会先思考出暴力算法怎么求解，然后再去思考一下怎么去进行优化。

朴素做法匹配字符串:
```cpp
// 有两个字符串 S[N](匹配的模板串)、P[M](比较短的字符串)
int i = 1, j = 1;
while (i < s.length()) {
  if (s[i] == p[j]) {
    i ++,j++;
  } else {
    i = i - j + 1;
    j = 0;
  }
  if (j == p.length()) {
    cout << i - j << endl;
    i = i - j + 1;
    j = 0;
  }
}
```

可以发现，在每次匹配失败之后我们都会，对 i 进行回溯，重新去对 j 进行匹配，这样消耗了大量时间，因此我们可以考虑对这个 i 的回溯进行一些优化，但是如果 i 不回溯的话，j 每次变回为 0，这样就会导致漏掉一些匹配。

因此我们需要预处理出来一个 j 值。对于每个点，

```cpp
next[i] = j 表示:
// 下面这两段是相等的
p[1...j] = p[i - j + 1, i]
```

kmp 算法匹配:


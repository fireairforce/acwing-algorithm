# Data-Structure

前面几种数据结构都是以数组模拟的。
原因如下:
- 效率问题
例如链表:
```cpp
struct Node 
{
  int val;
  Node *next;
}
```
每次 new 一个新的节点都会去调用结构体，消耗很大，平时做笔试的时候不会采用这种动态的方式。(可以改进之后使用，例如初始化的时候做一些处理)。一般都采用数组来去做模拟，即静态链表的。

## 链表 && 邻接表
链表可以用指针 + 结构体。但如上效率是很低的，因此这里都是采用数组来进行模拟。

### 单链表
单链表里面用比较多的是领接表(用来存储图和树)

单链表是可以在任意位置插入值的，但是想实现在 O(1) 的时间之内插入某个值，需要确定插入的位置，因为单链表能在O(1)的时间里面找到某个节点的下一个节点的值，但是不能找到其上一个节点的值。

### 双链表
一般用来优化某些问题.
相比较于单链表存在两个指针。一个指向前面，一个指向后面。
```bash
一般我们定义 int l[N], r[N]; 来存节点
让下标为 0 的点为 head, 下标为 1 的点为 tail
```

## 栈与队列

栈:
```cpp
const int N = 100010;

int stk[N], tt;

// insert
stk[++tt] = x;

// 弹出
tt --;

// 判断栈位空
if (tt > 0) // 不空
// 否则空

// 栈顶 
stk[tt]
```

队列:
```cpp
// 在队尾插入元素，队头弹出元素
int q[N], hh, tt = -1;

// 插入
q[++tt] = x;

// 弹出 
hh ++;

if (hh <= tt) {
  // not empty
} else {
  // empty
}

// 取出队头元素
q[hh]
// 队尾元素
q[tt]
```

## 单调栈
最常见的一个应用情景是给定一个序列，要求求出每个数`左边/右边`离它最近的比它`大/小`的数。

可以见例题。单调栈考虑的方式考虑方式其实和双指针差不多。用于降低问题的时间复杂度。

暴力解法走个两层循环就可以出来结果。因此考虑在外层循环的时候使用一个栈来作为优化，

## kmp
